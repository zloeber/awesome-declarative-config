{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"An awesome list of declaratively configured applications and engines. Introduction Understanding Declarative Configuration Benefits Drawbacks Declarative Categories Declarative Manifests What Does Not Qualify The List Contribute Links Resources Introduction \u00b6 This is a list of awesome application which qualify as being declaratively configured. To understand what qualifies for this list, it is important to understand what declarative actually means. Declarative programming as defined in wikipedia is; \u201ca style of building the structure and elements of computer programs\u2014that expresses the logic of a computation without describing its control flow.\u201d An operator can declare what they want and the app makes it a reality by handling all the gritty details. Truly declarative languages that must figure out several interdependencies in the correct order in a repeatable manner will often employ graph theory such as direct acycle graphs(DAGS) to achieve their desired results. For example, a common declarative infrastructure tool known as terraform will use such algorithms along with a separate \u2018state\u2019 to speed up future runs and track the current known state after the declarative manifest has processed. In theory, this allows not only to deploy repeatable infrastructure for IT projects, but also can be used to control configuration drift by making the deployment itself idempotent. At a high level, a declaratively structured workflow looks pretty simple. The declarative engine is an abstraction layer that produces a desired end state from an input manifest written in a Domain Specific Language (DSL). This is a simple but powerful approach to application configuration and deployment workflows. Understanding Declarative Configuration \u00b6 The next few sections will provide foundational knowledge of declarative configuration. Benefits \u00b6 Several benefits emerge when using declarative engines to accomplish configuration tasks. Declarative configuration is; Easier to comprehend More succinct More reusable Idempotent Naturally resistent to configuration skew/drift Easy to check into version control Is often self-documenting Drawbacks \u00b6 There are drawbacks to this model as well. A few of these in no particular order. State management can be trickier to maneuver in some cases Upgrade of the underlying DSL schema can be a labyrinthine effort Version \u2018pinning\u2019 of configuration code becomes far more important Exclusivity of declarative configuration is almost required to reap the aforementioned benefits These drawbacks typically emerge in more complex declarative configurations. Declarative Categories \u00b6 Three broad categories of software will be considered for this list. The difference between them is a bit fuzzy but largely comes down to the target of the declarative manifests it consumes. Categories are as follows: Engines - Engines consume declarative manifests in some manner to simplify the attainment of desired state of a broad range of systems outside of the application itself. A prime example of a declarative engine would be Terraform. Applications - An application which is able to be configured declaratively or uses declarative manifests to accomplish application specific tasks. One example of a declarative application would be a Kubernetes operator. Platforms - A platform which consumes declarative manifests to configure or deploy platform specific elements. A great example of a declarative platform would be Kubernetes. Declarative Manifests \u00b6 The crux of a declarative configuration file is the manifest used to actually declare desired state. The input for a declarative application, platform, or engine will be one or more declarative manifests that meet the following criteria to be on this list; Are human readable Follow a concrete configuration schema or language definition Present a reduction of overall complexity to the operator We do not include dependency graphing or other more complex mechanisms as a requirement as it is perfectly plausible to meet the above criteria without advanced pathing/convergence techniques. The manifest format is not relevant either. They need only be human readable so that one can look at a manifest and understand what the end state will be if processed. This means toml, hcl, json, ini, cuelang, and the ever loved/hated yaml are perfectly valid declarative configuration formats on this list . What Does Not Qualify \u00b6 Some applications that have broad industry support can be used as a means to enable declarative declaration for any number of other applications. For example, a great deal of effort has gone into modernizing applications to run on Kubernetes via helm. These helm packages come in the form of versioned \u2018charts\u2019 that can then be used by operators to express, in a declarative manner, a deployment of that application to the Kubernetes platform. These charts can mask an underlying non-declaratively configured application. These charts are the source manifest for a declarative tool to apply the desired state against a Kubernetes cluster. As such, individual helm charts are not going to be considered for this list but rather, helm itself would be on this list as an application that facilitates declarative configuration. The List \u00b6 The list can be viewed via Github here or be consumed in its published form here . Contribute \u00b6 Contributions welcome! The list itself is a declarative YAML file, list.yml , that you can submit new contributions to quite easily. This one yaml file goes through some testing to ensure validity via Culang . After the hard tests have been passed, the entry itself will be go through the soft-test and (hopefully) approved. The final merge will kick off a gomplate template merge with list.yml as the datasource. We then assemble the mkdocs files as defined in the declarative mkdocs.yml file and build the published site on github pages. Sub-pages for the mkdocs published version are soft-linked into the docs folder. NOTE I put forth a bit of effort to generate the list via cuelang natively but was not able to effectively make that happen. Perhaps someone else can? (hint hint) Read the contribution guidelines for more info and other guidelines for submitting change requests to this project. Links \u00b6 Mermaid.js online editor Resources \u00b6 Declarative configuration management Declarative Programming Opinion Article","title":"Home"},{"location":"#introduction","text":"This is a list of awesome application which qualify as being declaratively configured. To understand what qualifies for this list, it is important to understand what declarative actually means. Declarative programming as defined in wikipedia is; \u201ca style of building the structure and elements of computer programs\u2014that expresses the logic of a computation without describing its control flow.\u201d An operator can declare what they want and the app makes it a reality by handling all the gritty details. Truly declarative languages that must figure out several interdependencies in the correct order in a repeatable manner will often employ graph theory such as direct acycle graphs(DAGS) to achieve their desired results. For example, a common declarative infrastructure tool known as terraform will use such algorithms along with a separate \u2018state\u2019 to speed up future runs and track the current known state after the declarative manifest has processed. In theory, this allows not only to deploy repeatable infrastructure for IT projects, but also can be used to control configuration drift by making the deployment itself idempotent. At a high level, a declaratively structured workflow looks pretty simple. The declarative engine is an abstraction layer that produces a desired end state from an input manifest written in a Domain Specific Language (DSL). This is a simple but powerful approach to application configuration and deployment workflows.","title":"Introduction"},{"location":"#understanding-declarative-configuration","text":"The next few sections will provide foundational knowledge of declarative configuration.","title":"Understanding Declarative Configuration"},{"location":"#benefits","text":"Several benefits emerge when using declarative engines to accomplish configuration tasks. Declarative configuration is; Easier to comprehend More succinct More reusable Idempotent Naturally resistent to configuration skew/drift Easy to check into version control Is often self-documenting","title":"Benefits"},{"location":"#drawbacks","text":"There are drawbacks to this model as well. A few of these in no particular order. State management can be trickier to maneuver in some cases Upgrade of the underlying DSL schema can be a labyrinthine effort Version \u2018pinning\u2019 of configuration code becomes far more important Exclusivity of declarative configuration is almost required to reap the aforementioned benefits These drawbacks typically emerge in more complex declarative configurations.","title":"Drawbacks"},{"location":"#declarative-categories","text":"Three broad categories of software will be considered for this list. The difference between them is a bit fuzzy but largely comes down to the target of the declarative manifests it consumes. Categories are as follows: Engines - Engines consume declarative manifests in some manner to simplify the attainment of desired state of a broad range of systems outside of the application itself. A prime example of a declarative engine would be Terraform. Applications - An application which is able to be configured declaratively or uses declarative manifests to accomplish application specific tasks. One example of a declarative application would be a Kubernetes operator. Platforms - A platform which consumes declarative manifests to configure or deploy platform specific elements. A great example of a declarative platform would be Kubernetes.","title":"Declarative Categories"},{"location":"#declarative-manifests","text":"The crux of a declarative configuration file is the manifest used to actually declare desired state. The input for a declarative application, platform, or engine will be one or more declarative manifests that meet the following criteria to be on this list; Are human readable Follow a concrete configuration schema or language definition Present a reduction of overall complexity to the operator We do not include dependency graphing or other more complex mechanisms as a requirement as it is perfectly plausible to meet the above criteria without advanced pathing/convergence techniques. The manifest format is not relevant either. They need only be human readable so that one can look at a manifest and understand what the end state will be if processed. This means toml, hcl, json, ini, cuelang, and the ever loved/hated yaml are perfectly valid declarative configuration formats on this list .","title":"Declarative Manifests"},{"location":"#what-does-not-qualify","text":"Some applications that have broad industry support can be used as a means to enable declarative declaration for any number of other applications. For example, a great deal of effort has gone into modernizing applications to run on Kubernetes via helm. These helm packages come in the form of versioned \u2018charts\u2019 that can then be used by operators to express, in a declarative manner, a deployment of that application to the Kubernetes platform. These charts can mask an underlying non-declaratively configured application. These charts are the source manifest for a declarative tool to apply the desired state against a Kubernetes cluster. As such, individual helm charts are not going to be considered for this list but rather, helm itself would be on this list as an application that facilitates declarative configuration.","title":"What Does Not Qualify"},{"location":"#the-list","text":"The list can be viewed via Github here or be consumed in its published form here .","title":"The List"},{"location":"#contribute","text":"Contributions welcome! The list itself is a declarative YAML file, list.yml , that you can submit new contributions to quite easily. This one yaml file goes through some testing to ensure validity via Culang . After the hard tests have been passed, the entry itself will be go through the soft-test and (hopefully) approved. The final merge will kick off a gomplate template merge with list.yml as the datasource. We then assemble the mkdocs files as defined in the declarative mkdocs.yml file and build the published site on github pages. Sub-pages for the mkdocs published version are soft-linked into the docs folder. NOTE I put forth a bit of effort to generate the list via cuelang natively but was not able to effectively make that happen. Perhaps someone else can? (hint hint) Read the contribution guidelines for more info and other guidelines for submitting change requests to this project.","title":"Contribute"},{"location":"#links","text":"Mermaid.js online editor","title":"Links"},{"location":"#resources","text":"Declarative configuration management Declarative Programming Opinion Article","title":"Resources"},{"location":"CODE-OF-CONDUCT/","text":"Contributor Covenant Code of Conduct \u00b6 Our Pledge \u00b6 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00b6 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others\u2019 private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00b6 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00b6 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00b6 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at zloeber@gmail.com. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project\u2019s leadership. Attribution \u00b6 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Code of Conduct"},{"location":"CODE-OF-CONDUCT/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"CODE-OF-CONDUCT/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"CODE-OF-CONDUCT/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others\u2019 private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"CODE-OF-CONDUCT/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"CODE-OF-CONDUCT/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"CODE-OF-CONDUCT/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at zloeber@gmail.com. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project\u2019s leadership.","title":"Enforcement"},{"location":"CODE-OF-CONDUCT/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Attribution"},{"location":"CONTRIBUTING/","text":"Contribution Guidelines \u00b6 Please note that this project is released with a Contributor Code of Conduct . By participating in this project you agree to abide by its terms. The process for contributing to this repo is as follows: Fork this repo Clone this repo to your local workstation Create a new branch Update list.yml to include your submission entry Optionally run make deps test to validate your entry Push your new branch with the updated list entry to Github Submit your PR for approval Updating your PR \u00b6 If the maintainers notice anything that we\u2019d like changed, we\u2019ll ask you to edit your PR before we merge it. There\u2019s no need to open a new PR, just edit the existing one. If you\u2019re not sure how to do that, here is a guide on the different ways you can update your PR so that we can merge it.","title":"Contributing"},{"location":"CONTRIBUTING/#contribution-guidelines","text":"Please note that this project is released with a Contributor Code of Conduct . By participating in this project you agree to abide by its terms. The process for contributing to this repo is as follows: Fork this repo Clone this repo to your local workstation Create a new branch Update list.yml to include your submission entry Optionally run make deps test to validate your entry Push your new branch with the updated list entry to Github Submit your PR for approval","title":"Contribution Guidelines"},{"location":"CONTRIBUTING/#updating-your-pr","text":"If the maintainers notice anything that we\u2019d like changed, we\u2019ll ask you to edit your PR before we merge it. There\u2019s no need to open a new PR, just edit the existing one. If you\u2019re not sure how to do that, here is a guide on the different ways you can update your PR so that we can merge it.","title":"Updating your PR"},{"location":"DEVELOPMENT/","text":"Development \u00b6 This document will cover how this list is generated and how you can setup a local development environment. This guide assumes you have Python3, make, and are using a Linux/Mac/WSL environment. Most tools used in this list are purposefully declarative in nature and are able to be run via standalone tooling. Once you have cloned this repository to your workstation you should be able to use the included Makefile for most local tasks. # Setup the local tools for further tasks make deps # Build and preview the website (http://localhost:8000 by default) make serve # Just build the local website (target path == ./site) make build # Publish the site to github pages make publish # validate the list.yml file make validate You can view additional tasks by running make without any arguments.","title":"Development"},{"location":"DEVELOPMENT/#development","text":"This document will cover how this list is generated and how you can setup a local development environment. This guide assumes you have Python3, make, and are using a Linux/Mac/WSL environment. Most tools used in this list are purposefully declarative in nature and are able to be run via standalone tooling. Once you have cloned this repository to your workstation you should be able to use the included Makefile for most local tasks. # Setup the local tools for further tasks make deps # Build and preview the website (http://localhost:8000 by default) make serve # Just build the local website (target path == ./site) make build # Publish the site to github pages make publish # validate the list.yml file make validate You can view additional tasks by running make without any arguments.","title":"Development"},{"location":"LIST/","text":"Awesome Declarative Apps \u00b6 An awesome list of declarative applications, engines, and platforms. Type - Engine \u00b6 terraform \u00b6 Category: infrastructure as code Url: https://www.terraform.io/ Description: Terraform is an open-source infrastructure as code software tool that provides a consistent CLI workflow to manage hundreds of cloud services. Terraform codifies cloud APIs into declarative configuration files. Cuelang \u00b6 Category: Configuration Runtime Url: https://cuelang.org Description: Configure, unify, execute Type - Platform \u00b6 kubernetes \u00b6 Category: container orchestration Url: https://kubernetes.io/ Description: Kubernetes, also known as K8s, is an open-source system for automating deployment, scaling, and management of containerized applications. Examples Example 0 - Basic Deployment A replica set of 3 pods will be deployed to Kubernetes. Each pod will run the nginx:1.7.9 container image exposing port 80 and be labeled with `app:nginx` for use in service abstraction. apiVersion: apps/v1 kind: Deployment metadata: name: nginx-deployment labels: app: nginx spec: replicas: 3 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.7.9 ports: - containerPort: 80 Type - Application \u00b6 ferret \u00b6 Category: web scraping Url: https://github.com/MontFerret/ferret Description: ferret is a web scraping system. It aims to simplify data extraction from the web for UI testing, machine learning, analytics and more. ferret allows users to focus on the data. It abstracts away the technical details and complexity of underlying technologies using its own declarative language. It is extremely portable, extensible, and fast. mkdocs \u00b6 Category: website generator Url: https://www.mkdocs.org/ Description: MkDocs is a fast, simple and downright gorgeous static site generator that\u2019s geared towards building project documentation. Documentation source files are written in Markdown, and configured with a single YAML configuration file. reagent \u00b6 Category: Testing Url: https://github.com/whytheplatypus/reagent Description: A cli and library for declaring what how an API is expected to behave and checking that hypothesis. editly \u00b6 Category: Multimedia Url: https://github.com/mifi/editly Description: Editly is a tool and framework for declarative NLE (non-linear video editing) using Node.js and ffmpeg. Editly allows you to easily and programmatically create a video from a set of clips, images, audio and titles, with smooth transitions and music overlaid. Editly has a simple CLI for quickly assembling a video from a set of clips or images, or you can use its more flexible JavaScript API. topicctl \u00b6 Category: Kafka Url: https://github.com/segmentio/topicctl Description: A tool for easy, declarative management of Kafka topics. Includes the ability to \u201capply\u201d topic changes from YAML as well as a repl for interactive exploration of brokers, topics, consumer groups, messages, and more. ignition \u00b6 Category: OS Runtime Configuration Url: https://github.com/kinvolk/ignition Description: Ignition is a low-level system configuration utility. The Ignition executable is part of the temporary initial root filesystem, the initramfs. When Ignition runs, it finds configuration data in a named location for a given environment, such as a file or URL, and applies it to the machine before switch_root is called to pivot to the machine\u2019s root filesystem. Ignition uses a JSON configuration file to represent the set of changes to be made.","title":"List"},{"location":"LIST/#awesome-declarative-apps","text":"An awesome list of declarative applications, engines, and platforms.","title":"Awesome Declarative Apps"},{"location":"LIST/#type-engine","text":"","title":"Type - Engine"},{"location":"LIST/#terraform","text":"Category: infrastructure as code Url: https://www.terraform.io/ Description: Terraform is an open-source infrastructure as code software tool that provides a consistent CLI workflow to manage hundreds of cloud services. Terraform codifies cloud APIs into declarative configuration files.","title":"terraform"},{"location":"LIST/#cuelang","text":"Category: Configuration Runtime Url: https://cuelang.org Description: Configure, unify, execute","title":"Cuelang"},{"location":"LIST/#type-platform","text":"","title":"Type - Platform"},{"location":"LIST/#kubernetes","text":"Category: container orchestration Url: https://kubernetes.io/ Description: Kubernetes, also known as K8s, is an open-source system for automating deployment, scaling, and management of containerized applications. Examples Example 0 - Basic Deployment A replica set of 3 pods will be deployed to Kubernetes. Each pod will run the nginx:1.7.9 container image exposing port 80 and be labeled with `app:nginx` for use in service abstraction. apiVersion: apps/v1 kind: Deployment metadata: name: nginx-deployment labels: app: nginx spec: replicas: 3 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx image: nginx:1.7.9 ports: - containerPort: 80","title":"kubernetes"},{"location":"LIST/#type-application","text":"","title":"Type - Application"},{"location":"LIST/#ferret","text":"Category: web scraping Url: https://github.com/MontFerret/ferret Description: ferret is a web scraping system. It aims to simplify data extraction from the web for UI testing, machine learning, analytics and more. ferret allows users to focus on the data. It abstracts away the technical details and complexity of underlying technologies using its own declarative language. It is extremely portable, extensible, and fast.","title":"ferret"},{"location":"LIST/#mkdocs","text":"Category: website generator Url: https://www.mkdocs.org/ Description: MkDocs is a fast, simple and downright gorgeous static site generator that\u2019s geared towards building project documentation. Documentation source files are written in Markdown, and configured with a single YAML configuration file.","title":"mkdocs"},{"location":"LIST/#reagent","text":"Category: Testing Url: https://github.com/whytheplatypus/reagent Description: A cli and library for declaring what how an API is expected to behave and checking that hypothesis.","title":"reagent"},{"location":"LIST/#editly","text":"Category: Multimedia Url: https://github.com/mifi/editly Description: Editly is a tool and framework for declarative NLE (non-linear video editing) using Node.js and ffmpeg. Editly allows you to easily and programmatically create a video from a set of clips, images, audio and titles, with smooth transitions and music overlaid. Editly has a simple CLI for quickly assembling a video from a set of clips or images, or you can use its more flexible JavaScript API.","title":"editly"},{"location":"LIST/#topicctl","text":"Category: Kafka Url: https://github.com/segmentio/topicctl Description: A tool for easy, declarative management of Kafka topics. Includes the ability to \u201capply\u201d topic changes from YAML as well as a repl for interactive exploration of brokers, topics, consumer groups, messages, and more.","title":"topicctl"},{"location":"LIST/#ignition","text":"Category: OS Runtime Configuration Url: https://github.com/kinvolk/ignition Description: Ignition is a low-level system configuration utility. The Ignition executable is part of the temporary initial root filesystem, the initramfs. When Ignition runs, it finds configuration data in a named location for a given environment, such as a file or URL, and applies it to the machine before switch_root is called to pivot to the machine\u2019s root filesystem. Ignition uses a JSON configuration file to represent the set of changes to be made.","title":"ignition"},{"location":"img/declarative-diagram/","text":"graph LR Manifest[Declarative Manifest (DSL)] Engine[[Declarative Engine]] State[Desired State] Manifest-->|Processed via|Engine Engine-->|Produces|State","title":"Declarative diagram"}]}